# Part 1
 For this part of the project, my strategy was to have one of the guests be the only one who could eat a cupcake, and every guest could only eat one cupcake.
 This way, whenever the designated guest had to replace a cupcake, he would know that a new person who had not eaten a cupcake before ate a cupcake. By making
 sure that every guest ate a cupcake, we can then know that every guest entered the labyrinth without having the guests communicate. I tested the code multiple  times with different threads and the thread behavior matches that of how the guests would behave using the strategy I mentioned above. To avoud race conditions  since multiple threads #are sharing resources, I used a lock whenever one of the guests enters the labyrinth. This not only ensures that the resources aren't   corrupted or changed improperly, but also to properly simulate that only one guest is in the labyrinth at once, making the code behave correctly.

# Part 2
For part 2, I chose the second strategy. I like it because it is more ordered than the first strategy because the threads aren't "fighting" to get in and in can be implemented easily like in part 1 with a lock. It's only downside is that there is no way of controlling which thread goes in first since we don't use a queue like in the third strategy. My code works properly with strategy 2 by having the threads check if the room is available by using a boolean. This simulates the sign on the door. Then, if the room is available, one of the threads gets the lock and goes into the room and then leaves. I tested my code with different number of threads and it always ends up with every thread being able to properly visit the vase. It also avoids having multiple threads access a critical section of the code at the same time which ensures efficiency and correctness.
